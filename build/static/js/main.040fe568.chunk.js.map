{"version":3,"sources":["assets/splashcube.gif","SplashScreen.js","ModalContext.js","Modal.js","App.js","reportWebVitals.js","index.js"],"names":["module","exports","SplashScreen","React","createElement","id","className","src","splashGif","alt","style","color","display","justifyContent","width","height","border","background","title","textAlign","role","aria-label","ModalContext","createContext","useModal","useContext","ModalProvider","_ref","children","isModalOpen","setIsModalOpen","useState","currentVideoID","setCurrentVideoID","openModal","useCallback","videoID","console","log","concat","closeModal","providerValue","useMemo","Provider","value","Modal","navigate","useNavigate","location","useLocation","videoInfo","setVideoInfo","isLoading","setIsLoading","modalRef","useRef","getEmbeddedVideoUrl","url","vimeoId","split","useEffect","videoIDFromURL","pathname","axios","get","then","response","data","catch","error","handleCloseModal","handleOuterClick","event","current","contains","target","document","addEventListener","body","classList","add","removeEventListener","remove","embeddedVideoUrl","URL","ref","onClick","e","stopPropagation","Fragment","videoName","allow","allowFullScreen","dangerouslySetInnerHTML","__html","Description","BASE_URL","Video","memo","onVideoClick","videoRef","inView","useInView","triggerOnce","rootMargin","handleMouseEnter","isMobile","play","handleMouseLeave","pause","loop","muted","playsInline","onMouseEnter","onMouseLeave","prevProps","nextProps","MemoizedMainContent","_ref2","scenes","uniqueVideoIDs","useParams","shuffledScenes","setShuffledScenes","array","i","length","j","Math","floor","random","shuffleArray","some","scene","handleVideoNameClick","onWelcomePage","navigateAndOpenModal","window","scrollTo","top","documentElement","clientHeight","behavior","setTimeout","map","video","index","key","sceneURL","Home","_ref3","initialLoad","showSplash","setShowSplash","scrollPositionBeforeNavigation","handleScroll","scrollThreshold","innerHeight","hasScrolledPastSplash","scrollY","replace","splashScreenStyle","AppWrapper","setScenes","setUniqueVideoIDs","async","scenesResponse","videosResponse","_","uniqBy","fetchContent","memoizedScenes","memoizedUniqueVideoIDs","Router","Suspense","fallback","Routes","Route","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","getElementById","render","StrictMode","App"],"mappings":"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","file":"static/js/main.040fe568.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/splashcube.9243f971.gif\";","import React from 'react';\nimport splashGif from './assets/splashcube.gif';\n\nfunction SplashScreen() {\n  return (\n    <div id=\"splash-section\" className=\"splash-screen\">\n      <div className=\"splash-screen\">\n        <div className=\"splash-content\">\n          <img src={splashGif} alt=\"Splash GIF\" className=\"splash-image\" />\n          <div className=\"splash-text\">\n            <p>\n              The Rubik’s Cube has 43,000,000,000,000,000,000 possible combinations... and <i>one</i> solution.\n            </p>\n            <p>\n              It's easy to appreciate the puzzle in its solved form: a universe of possibility reduced to six harmonic faces. But <i>leaving</i> it solved would squander all that potential.\n            </p>\n            <p>\n              <b>VU JA DE</b> exists to scramble “solved” arrangements of cultural ephemera. To flip the switch from <i style={{ color: 'blue' }}>solving</i> to <i style={{ color: 'blue' }}>playing.</i> From <i style={{ color: 'blue' }}>I've been here before</i> to <i style={{ color: 'blue' }}>I've never seen this before.</i> From <i style={{ color: 'blue' }}>déjà vu</i> to <i style={{ color: 'blue' }}>vujà de.</i>\n            </p>\n            <p>\n              Like the 43 quintillion permutations of the Rubik's Cube, these stories are starting points, not resolutions. They're not made for an algorithmic feed or a distracted scroll, which is why they come to your email. Explore on your own time, at your own pace, with nobody trying to sell you something in the process.\n            </p>\n            <div className=\"splash-embed\" style={{ display: 'flex', justifyContent: 'center' }}>\n            <iframe\n              src=\"https://vujadeworld.substack.com/embed\"\n              width=\"480\"\n              height=\"150\"\n              style={{ border: '0px solid #EEE', background: 'white' }}\n              title=\"VUJADE Substack\"\n            ></iframe>\n          </div>\n            <p style={{ textAlign: 'center' }}>\n            <span role=\"img\" aria-label=\"Rolling Eyes Emoji\">🙄</span><b> Keep scrolling to enter </b><span role=\"img\" aria-label=\"Pointing Down Emoji\">👇</span>\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default SplashScreen;\n","import React, { createContext, useContext, useState, useMemo, useCallback } from 'react';\n\nconst ModalContext = createContext();\n\nexport const useModal = () => useContext(ModalContext);\n\nexport const ModalProvider = ({ children }) => {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [currentVideoID, setCurrentVideoID] = useState(null);\n\n  // OpenModal function updated to simply set the modal state and current video ID.\n  // This handles opening the modal both programmatically and via URL navigation.\n  const openModal = useCallback((videoID) => {\n    console.log(`Opening modal for videoID: ${videoID}`);\n    setIsModalOpen(true);\n    setCurrentVideoID(videoID);\n  }, []);\n\n  // CloseModal function simplified to remove the previously included navigateCallback parameter.\n  // The function now purely focuses on closing the modal and resetting relevant state.\n  // This change is based on the finding that navigateCallback was unnecessary and could potentially cause routing issues.\n  const closeModal = useCallback(() => {\n    console.log('Closing modal');\n    setIsModalOpen(false);\n    setCurrentVideoID(null);\n  }, []);\n\n  // The context value is memoized to ensure that consumers of the context do not re-render unnecessarily.\n  // This is particularly important for performance, as it prevents unnecessary re-renders of components that use this context.\n  const providerValue = useMemo(() => ({\n    isModalOpen,\n    currentVideoID,\n    openModal,\n    closeModal\n  }), [isModalOpen, currentVideoID, openModal, closeModal]);\n\n  return (\n    <ModalContext.Provider value={providerValue}>\n      {children}\n    </ModalContext.Provider>\n  );\n};","import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport axios from 'axios';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useModal } from './ModalContext';\n\nconst BASE_URL = process.env.NODE_ENV === 'production'\n  ? 'https://vujade-site-bd6c94750c62.herokuapp.com'\n  : 'http://127.0.0.1:5000';\n\n  function Modal() {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { isModalOpen, currentVideoID, closeModal } = useModal();\n    const [videoInfo, setVideoInfo] = useState(null);\n    const [isLoading, setIsLoading] = useState(false);\n    const modalRef = useRef(null);\n\n  // Function to transform video URLs for embedding\n  const getEmbeddedVideoUrl = useCallback((url) => {\n    const parts = url.split(\"vimeo.com/\")[1];\n    const vimeoId = parts.split('/')[0];\n    return `https://player.vimeo.com/video/${vimeoId}`;\n  }, []);\n\n   // Fetch and set video info based on URL change or currentVideoID update\n   useEffect(() => {\n    const videoIDFromURL = location.pathname.split('/')[1];\n    if (videoIDFromURL && (videoIDFromURL !== currentVideoID || !videoInfo)) {\n      setIsLoading(true); // Indicate loading\n      axios.get(`${BASE_URL}/api/video_info/${videoIDFromURL}`)\n        .then(response => {\n          setVideoInfo(response.data);\n          setIsLoading(false); // Reset loading state\n        })\n        .catch(error => {\n          console.error('Error fetching video info: ', error);\n          setIsLoading(false); // Ensure loading state is reset even on error\n        });\n    }\n  }, [location.pathname, currentVideoID, videoInfo]);\n\n  const handleCloseModal = useCallback(() => {\n    closeModal();\n    navigate('/'); // Use navigate to change URL back to root\n  }, [closeModal, navigate]);\n\n  // Handle closing modal by clicking outside\n  useEffect(() => {\n    const handleOuterClick = (event) => {\n      if (modalRef.current && !modalRef.current.contains(event.target)) {\n        handleCloseModal();\n      }\n    };\n\n    if (isModalOpen) {\n      document.addEventListener('mousedown', handleOuterClick);\n      document.body.classList.add('body-lock');\n    } else {\n      document.removeEventListener('mousedown', handleOuterClick);\n      document.body.classList.remove('body-lock');\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleOuterClick);\n      document.body.classList.remove('body-lock');\n    };\n  }, [isModalOpen, closeModal, handleCloseModal]);\n\n  // Memoize embedded video URL\n  const embeddedVideoUrl = useMemo(() => videoInfo ? getEmbeddedVideoUrl(videoInfo.URL) : null, [videoInfo, getEmbeddedVideoUrl]);\n\n  if (isLoading || !videoInfo) { // Show loading indicator or prevent rendering if videoInfo is not available yet\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    <div className={`modal ${isModalOpen ? 'open' : ''}`} ref={modalRef}>\n      <div className=\"modal-content\" onClick={(e) => e.stopPropagation()}>\n        <span className=\"close\" onClick={handleCloseModal}>&times;</span>\n        <>\n          <h2>{videoInfo ? videoInfo.videoName : 'Loading...'}</h2>\n          <div className=\"embed-container\">\n            {videoInfo && (\n              <iframe\n                src={embeddedVideoUrl}\n                allow=\"autoplay; fullscreen\"\n                allowFullScreen\n                title={videoInfo ? videoInfo.videoName : ''}\n              ></iframe>\n            )}\n          </div>\n          {videoInfo && <div dangerouslySetInnerHTML={{ __html: videoInfo.Description }}></div>}\n        </>\n      </div>\n    </div>\n  );\n}\n\nexport default Modal;\n","import React, { useState, useEffect, Suspense, useMemo, useRef, useCallback } from 'react';\nimport axios from 'axios';\nimport './App.css';\nimport SplashScreen from './SplashScreen';\nimport { BrowserRouter as Router, Routes, Route, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { ModalProvider, useModal } from './ModalContext';\nimport Modal from './Modal';\nimport _ from 'lodash';\nimport { useInView } from 'react-intersection-observer';\nimport { isMobile } from 'react-device-detect';\n\n// Base URL setup for different environments\nconst BASE_URL = process.env.NODE_ENV === 'production'\n  ? 'https://vujade-site-bd6c94750c62.herokuapp.com'\n  : 'http://127.0.0.1:5000';\n\n// Video component for individual videos, optimized with memo for performance\nconst Video = React.memo(({ src, videoID, onVideoClick }) => {\n  const videoRef = useRef(null);\n  const { ref, inView } = useInView({\n    triggerOnce: true,\n    rootMargin: '50px 0px',\n  });\n\n  // Handle play on hover for desktop devices\n  const handleMouseEnter = useCallback(() => {\n    if (!isMobile && videoRef.current) {\n      videoRef.current.play().catch(error => console.error(\"Play was interrupted.\", error));\n    }\n  }, []);\n\n  // Handle pause on mouse leave for desktop devices\n  const handleMouseLeave = useCallback(() => {\n    if (!isMobile && videoRef.current) {\n      videoRef.current.pause();\n    }\n  }, []);\n\n  // Autoplay functionality for mobile devices when the video is in view\n  useEffect(() => {\n    if (isMobile && inView && videoRef.current) {\n      videoRef.current.play().catch(error => console.log(\"Autoplay was prevented.\", error));\n    }\n  }, [inView]);\n\n  return (\n    <div ref={ref} style={{ width: '100%', height: 'auto' }}>\n      {inView && (\n        <video\n          ref={videoRef}\n          src={src}\n          loop\n          muted\n          playsInline\n          onClick={() => {\n            console.log(`Video clicked: ${videoID}`);\n            onVideoClick(videoID);\n          }}\n          onMouseEnter={handleMouseEnter}\n          onMouseLeave={handleMouseLeave}\n          style={{ width: '100%', height: 'auto' }}\n        />\n      )}\n    </div>\n  );\n}, (prevProps, nextProps) => prevProps.videoID === nextProps.videoID && prevProps.src === nextProps.src);\n\n// Function to shuffle an array\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\n// MainContent component with video shuffling integrated\nfunction MainContent({ scenes, uniqueVideoIDs }) {\n  const navigate = useNavigate();\n  const { videoID } = useParams();\n  const location = useLocation();\n  const { openModal, currentVideoID } = useModal();\n  const [shuffledScenes, setShuffledScenes] = useState([]);\n\n  useEffect(() => {\n    setShuffledScenes(shuffleArray([...scenes]));\n  }, [scenes]);\n\n  useEffect(() => {\n    if (videoID && scenes.some(scene => scene.videoID === videoID) && currentVideoID !== videoID) {\n      console.log(`Effect to open modal for videoID: ${videoID}`);\n      openModal(videoID);\n    }\n  }, [videoID, scenes, openModal, currentVideoID]);\n\n  const handleVideoNameClick = useCallback((id) => {\n    const onWelcomePage = location.pathname === '/welcome';\n  \n    // Function to navigate and open the modal\n    const navigateAndOpenModal = () => {\n      if (!onWelcomePage || location.pathname !== `/${id}`) {\n        navigate(`/${id}`); // Navigate only if not already on the target path\n      }\n      openModal(id);\n    };\n  \n    if (onWelcomePage) {\n      window.scrollTo({\n        top: document.documentElement.clientHeight,\n        behavior: 'smooth'\n      });\n  \n      setTimeout(() => {\n        navigate('/');\n        console.log(`Preparing to open modal for videoID: ${id}`);\n        navigateAndOpenModal();\n      }, 600);\n    } else {\n      navigateAndOpenModal();\n    }\n  }, [openModal, navigate, location.pathname]);  \n\n  return (\n    <div id=\"videos-section\" className=\"App\">\n      <div className=\"video-menu\">\n        {uniqueVideoIDs.map((video, index) => (\n          <div key={`${video.videoID}-${index}`} onClick={() => handleVideoNameClick(video.videoID)} className=\"video-menu-item\">\n            {video.videoName}\n          </div>\n        ))}\n      </div>\n      <div className=\"video-grid\">\n        {shuffledScenes.map(scene => (\n          <Video\n            key={scene.sceneURL}\n            src={scene.sceneURL}\n            videoID={scene.videoID}\n            onVideoClick={handleVideoNameClick}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Wrap MainContent with React.memo for performance optimization\nconst MemoizedMainContent = React.memo(MainContent);\n\nfunction Home({ scenes, uniqueVideoIDs }) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const initialLoad = useRef(true);\n  const [showSplash, setShowSplash] = useState(location.pathname === '/welcome');\n\n  // This ref is used to store the scroll position before the URL change\n  const scrollPositionBeforeNavigation = useRef(0);\n\n  const handleScroll = useCallback(() => {\n    const scrollThreshold = window.innerHeight * 1.0;\n    const hasScrolledPastSplash = window.scrollY > scrollThreshold;\n\n    if (location.pathname === '/welcome' && hasScrolledPastSplash && showSplash) {\n      // Store the current scroll position before changing the URL\n      scrollPositionBeforeNavigation.current = window.scrollY;\n\n      navigate('/', { replace: true });\n      setShowSplash(false); // Update state to hide splash screen\n    }\n  }, [navigate, location.pathname, showSplash]);\n\n  useEffect(() => {\n    // Add scroll event listener on mount\n    window.addEventListener('scroll', handleScroll);\n\n    // Cleanup on unmount\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  useEffect(() => {\n    if (!showSplash) {\n      // Restore the scroll position after the splash screen is hidden\n      console.log(`Scroll position before navigation: ${scrollPositionBeforeNavigation.current}`);\n      window.scrollTo(0, scrollPositionBeforeNavigation.current);\n      console.log('Scroll position after splash screen hidden, restored to previous state');\n    }\n  }, [showSplash]);\n\n  useEffect(() => {\n    if (initialLoad.current) {\n      initialLoad.current = false; // Mark initial load as done\n    } else {\n      // Adjust logic based on navigation that does not involve the initial load\n      setShowSplash(location.pathname === '/welcome');\n    }\n  }, [location.pathname]);\n\n  const splashScreenStyle = showSplash ? {} : { display: 'none' }; // Hide splash screen completely when not visible\n\n  return (\n    <>\n      <div style={splashScreenStyle}>\n        <SplashScreen />\n      </div>\n      <MemoizedMainContent scenes={scenes} uniqueVideoIDs={uniqueVideoIDs} />\n    </>\n  );\n}\n\nfunction AppWrapper() {\n  // State for scenes and unique video IDs\n  const [scenes, setScenes] = useState([]);\n  const [uniqueVideoIDs, setUniqueVideoIDs] = useState([]);\n\n  useEffect(() => {\n    // Fetch content from the API\n    const fetchContent = async () => {\n      try {\n        const scenesResponse = await axios.get(`${BASE_URL}/api/scenes`);\n        setScenes(scenesResponse.data);\n        const videosResponse = await axios.get(`${BASE_URL}/api/videos`);\n        setUniqueVideoIDs(_.uniqBy(videosResponse.data, 'videoID'));\n        console.log('Fetched scenes:', scenesResponse.data);\n        console.log('Fetched videos:', videosResponse.data);\n      } catch (error) {\n        console.error('Error fetching content: ', error);\n      }\n    };\n    fetchContent();\n  }, []);\n\n  // Use useMemo to memoize scenes and uniqueVideoIDs so they don't cause unnecessary re-renders\n  const memoizedScenes = useMemo(() => scenes, [scenes]);\n  const memoizedUniqueVideoIDs = useMemo(() => uniqueVideoIDs, [uniqueVideoIDs]);\n\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <ModalProvider>\n          <Routes>\n            <Route path=\"/welcome\" element={<Home scenes={memoizedScenes} uniqueVideoIDs={memoizedUniqueVideoIDs} />} />\n            <Route path=\"/\" element={<Home scenes={memoizedScenes} uniqueVideoIDs={memoizedUniqueVideoIDs} />} />\n            <Route path=\"/:videoID\" element={\n              <>\n                <Home scenes={memoizedScenes} uniqueVideoIDs={memoizedUniqueVideoIDs} />\n                <Modal />\n              </>\n            } />\n          </Routes>\n        </ModalProvider>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default AppWrapper;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport { ModalProvider } from './ModalContext';\nimport reportWebVitals from './reportWebVitals';\n\n// Use the createRoot API\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <ModalProvider>\n      <App />\n    </ModalProvider>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}