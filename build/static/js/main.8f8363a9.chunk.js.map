{"version":3,"sources":["cube-master/js/three/OrbitControls.js","cube-master/js/cube/Constants.js","cube-master/js/cube/RotationMatrices.js","cube-master/js/cube/Sticker.js","cube-master/js/cube/Cubie.js","cube-master/js/cube/Cube.js","cube-master/js/cube/main.js","ModalContext.js","Modal.js","App.js","reportWebVitals.js","index.js"],"names":["OrbitControls","object","domElement","undefined","console","warn","document","error","this","enabled","target","Vector3","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","enableKeys","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","changeEvent","update","state","STATE","NONE","offset","quat","Quaternion","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","rotateLeft","sphericalDelta","min","max","isFinite","makeSafe","radius","scale","addScaledVector","panOffset","add","setFromSpherical","lookAt","multiplyScalar","set","zoomChanged","distanceToSquared","EPS","dot","quaternion","dispose","removeEventListener","onContextMenu","onPointerDown","onMouseWheel","onTouchStart","onTouchEnd","onTouchMove","ownerDocument","onPointerMove","onPointerUp","onKeyDown","type","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","getZoomScale","pow","angle","rotateUp","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","isPerspectiveCamera","targetDistance","length","tan","fov","clientHeight","matrix","isOrthographicCamera","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","event","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","x","y","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","subVectors","handleTouchMovePan","handleTouchMoveDolly","pointerType","mouseAction","preventDefault","focus","window","button","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","addEventListener","onMouseDown","log","concat","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","keyCode","onMouseMove","onMouseUp","stopPropagation","handleMouseWheel","needsUpdate","handleKeyDown","handleTouchStartDollyPan","DOLLY_ROTATE","handleTouchStartDollyRotate","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","prototype","Object","create","EventDispatcher","constructor","MapControls","call","Axes","freeze","POSITIVE","X","Y","Z","NEGATIVE","AxisVectors","THREE","MoveFlags","SOLUTION_START","SOLUTION_END","ClickFlags","ROTATION","CUBIE","KeysToMoves","u","d","f","b","r","l","m","e","s","z","U","D","F","B","R","L","M","E","S","wu","wd","wf","wb","wr","wl","wU","wD","wF","wB","wR","wL","rotationMatrices","cos","sin","axisEnum","getRotationMatrix","axis","shape","size","moveTo","pos","lineTo","quadraticCurveTo","roundedSquareGeometry","center","Sticker","facingVector","videoURL","positionVector","fixedPositionVector","fixedFacingVector","video","createElement","crossOrigin","src","load","muted","loop","play","catch","texture","minFilter","magFilter","format","material","map","side","mesh","updatePosition","rotation","abs","axes","values","forEach","rest","filter","elt","lockPosition","round","turn","dir","rotationMatrix","applyMatrix3","rotate","rotateOnWorldAxis","eps","absarc","height","width","roundedBoxGeometry","depth","bevelEnabled","bevelSegments","smoothness","steps","bevelSize","radius0","bevelThickness","curveSegments","materialBlack","color","Cubie","cubieVideoURLs","animating","animateAxis","animateDir","stickers","videoIndex","push","vector","sticker","Cube","scene","videoURLs","cubies","meshes","stickersMap","Map","slice","cubie","uuid","fn","repr","getColor","cubeRepr","line","join","move","moveStr","moveLayer","axisValue","animDir","CubeMasterInit","holdingW","mouse","delta","raycaster","getHeight","innerHeight","moveBuffer","solving","getElementById","background","camera","innerWidth","renderer","antialias","setPixelRatio","devicePixelRatio","setSize","appendChild","controls","cube","rotationPixelCutoff","updateRotationPixelCutoff","halfWidth","project","clock","getDelta","shift","animate","requestAnimationFrame","render","key","onWindowResize","aspect","offsetX","offsetY","onDocumentMouseDown","onDocumentMouseUp","onDocumentMouseMove","chosenAxis","chosenDir","selectedObject","dragging","tagName","toLowerCase","setFromCamera","intersects","intersectObjects","has","selectedSticker","get","ModalContext","createContext","ModalProvider","_ref","children","isModalOpen","setIsModalOpen","useState","currentVideoID","setCurrentVideoID","openModal","useCallback","videoID","closeModal","providerValue","useMemo","React","Provider","value","Modal","navigate","useNavigate","location","useLocation","useContext","videoInfo","setVideoInfo","isLoading","setIsLoading","modalRef","useRef","getEmbeddedVideoUrl","url","vimeoId","split","useEffect","videoIDFromURL","pathname","axios","then","response","data","handleCloseModal","embeddedVideoUrl","URL","className","onClick","ref","Fragment","videoName","allow","allowFullScreen","title","dangerouslySetInnerHTML","__html","Description","BASE_URL","CubeWithVideos","cubeVideos","setCubeVideos","cubeMasterInitialized","async","shuffledScenes","_","shuffle","sceneURL","fetchCubeVideos","current","id","VideoMenu","videoNames","setVideoNames","name","fetchVideoNames","Home","AppWrapper","scenes","setScenes","uniqueVideoIDs","setUniqueVideoIDs","scenesResponse","videosResponse","uniqBy","fetchContent","memoizedScenes","memoizedUniqueVideoIDs","Router","Suspense","fallback","Routes","Route","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","StrictMode","App"],"mappings":"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","file":"static/js/main.8f8363a9.chunk.js","sourcesContent":["import {\n    EventDispatcher,\n    MOUSE,\n    Quaternion,\n    Spherical,\n    TOUCH,\n    Vector2,\n    Vector3,\n} from \"three\";\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nvar OrbitControls = function (object, domElement) {\n    if (domElement === undefined)\n        console.warn(\n            'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.'\n        );\n    if (domElement === document)\n        console.error(\n            'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.'\n        );\n\n    this.object = object;\n    this.domElement = domElement;\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    this.target = new Vector3();\n\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // How far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = false;\n    this.dampingFactor = 0.05;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n    this.panSpeed = 1.0;\n    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // Set to false to disable use of the keys\n    this.enableKeys = true;\n\n    // The four arrow keys\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        LEFT: MOUSE.ROTATE,\n        MIDDLE: MOUSE.DOLLY,\n        RIGHT: MOUSE.PAN,\n    };\n\n    // Touch fingers\n    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = function () {\n        return spherical.phi;\n    };\n\n    this.getAzimuthalAngle = function () {\n        return spherical.theta;\n    };\n\n    this.saveState = function () {\n        scope.target0.copy(scope.target);\n        scope.position0.copy(scope.object.position);\n        scope.zoom0 = scope.object.zoom;\n    };\n\n    this.reset = function () {\n        scope.target.copy(scope.target0);\n        scope.object.position.copy(scope.position0);\n        scope.object.zoom = scope.zoom0;\n\n        scope.object.updateProjectionMatrix();\n        scope.dispatchEvent(changeEvent);\n\n        scope.update();\n\n        state = STATE.NONE;\n    };\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = (function () {\n        var offset = new Vector3();\n\n        // so camera.up is the orbit axis\n        var quat = new Quaternion().setFromUnitVectors(\n            object.up,\n            new Vector3(0, 1, 0)\n        );\n        var quatInverse = quat.clone().invert();\n\n        var lastPosition = new Vector3();\n        var lastQuaternion = new Quaternion();\n\n        var twoPI = 2 * Math.PI;\n\n        return function update() {\n            var position = scope.object.position;\n\n            offset.copy(position).sub(scope.target);\n\n            // rotate offset to \"y-axis-is-up\" space\n            offset.applyQuaternion(quat);\n\n            // angle from z-axis around y-axis\n            spherical.setFromVector3(offset);\n\n            if (scope.autoRotate && state === STATE.NONE) {\n                rotateLeft(getAutoRotationAngle());\n            }\n\n            if (scope.enableDamping) {\n                spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n            } else {\n                spherical.theta += sphericalDelta.theta;\n                spherical.phi += sphericalDelta.phi;\n            }\n\n            // restrict theta to be between desired limits\n\n            var min = scope.minAzimuthAngle;\n            var max = scope.maxAzimuthAngle;\n\n            if (isFinite(min) && isFinite(max)) {\n                if (min < -Math.PI) min += twoPI;\n                else if (min > Math.PI) min -= twoPI;\n\n                if (max < -Math.PI) max += twoPI;\n                else if (max > Math.PI) max -= twoPI;\n\n                if (min <= max) {\n                    spherical.theta = Math.max(\n                        min,\n                        Math.min(max, spherical.theta)\n                    );\n                } else {\n                    spherical.theta =\n                        spherical.theta > (min + max) / 2\n                            ? Math.max(min, spherical.theta)\n                            : Math.min(max, spherical.theta);\n                }\n            }\n\n            // restrict phi to be between desired limits\n            spherical.phi = Math.max(\n                scope.minPolarAngle,\n                Math.min(scope.maxPolarAngle, spherical.phi)\n            );\n\n            spherical.makeSafe();\n\n            spherical.radius *= scale;\n\n            // restrict radius to be between desired limits\n            spherical.radius = Math.max(\n                scope.minDistance,\n                Math.min(scope.maxDistance, spherical.radius)\n            );\n\n            // move target to panned location\n\n            if (scope.enableDamping === true) {\n                scope.target.addScaledVector(panOffset, scope.dampingFactor);\n            } else {\n                scope.target.add(panOffset);\n            }\n\n            offset.setFromSpherical(spherical);\n\n            // rotate offset back to \"camera-up-vector-is-up\" space\n            offset.applyQuaternion(quatInverse);\n\n            position.copy(scope.target).add(offset);\n\n            scope.object.lookAt(scope.target);\n\n            if (scope.enableDamping === true) {\n                sphericalDelta.theta *= 1 - scope.dampingFactor;\n                sphericalDelta.phi *= 1 - scope.dampingFactor;\n\n                panOffset.multiplyScalar(1 - scope.dampingFactor);\n            } else {\n                sphericalDelta.set(0, 0, 0);\n\n                panOffset.set(0, 0, 0);\n            }\n\n            scale = 1;\n\n            // update condition is:\n            // min(camera displacement, camera rotation in radians)^2 > EPS\n            // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n            if (\n                zoomChanged ||\n                lastPosition.distanceToSquared(scope.object.position) > EPS ||\n                8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n            ) {\n                scope.dispatchEvent(changeEvent);\n\n                lastPosition.copy(scope.object.position);\n                lastQuaternion.copy(scope.object.quaternion);\n                zoomChanged = false;\n\n                return true;\n            }\n\n            return false;\n        };\n    })();\n\n    this.dispose = function () {\n        scope.domElement.removeEventListener(\n            \"contextmenu\",\n            onContextMenu,\n            false\n        );\n\n        scope.domElement.removeEventListener(\n            \"pointerdown\",\n            onPointerDown,\n            false\n        );\n        scope.domElement.removeEventListener(\"wheel\", onMouseWheel, false);\n\n        scope.domElement.removeEventListener(\"touchstart\", onTouchStart, false);\n        scope.domElement.removeEventListener(\"touchend\", onTouchEnd, false);\n        scope.domElement.removeEventListener(\"touchmove\", onTouchMove, false);\n\n        scope.domElement.ownerDocument.removeEventListener(\n            \"pointermove\",\n            onPointerMove,\n            false\n        );\n        scope.domElement.ownerDocument.removeEventListener(\n            \"pointerup\",\n            onPointerUp,\n            false\n        );\n\n        scope.domElement.removeEventListener(\"keydown\", onKeyDown, false);\n\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    };\n\n    //\n    // internals\n    //\n\n    var scope = this;\n\n    var changeEvent = { type: \"change\" };\n    var startEvent = { type: \"start\" };\n    var endEvent = { type: \"end\" };\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_PAN: 4,\n        TOUCH_DOLLY_PAN: 5,\n        TOUCH_DOLLY_ROTATE: 6,\n    };\n\n    var state = STATE.NONE;\n\n    var EPS = 0.000001;\n\n    // current position in spherical coordinates\n    var spherical = new Spherical();\n    var sphericalDelta = new Spherical();\n\n    var scale = 1;\n    var panOffset = new Vector3();\n    var zoomChanged = false;\n\n    var rotateStart = new Vector2();\n    var rotateEnd = new Vector2();\n    var rotateDelta = new Vector2();\n\n    var panStart = new Vector2();\n    var panEnd = new Vector2();\n    var panDelta = new Vector2();\n\n    var dollyStart = new Vector2();\n    var dollyEnd = new Vector2();\n    var dollyDelta = new Vector2();\n\n    function getAutoRotationAngle() {\n        return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n        return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function rotateLeft(angle) {\n        sphericalDelta.theta -= angle;\n    }\n\n    function rotateUp(angle) {\n        sphericalDelta.phi -= angle;\n    }\n\n    var panLeft = (function () {\n        var v = new Vector3();\n\n        return function panLeft(distance, objectMatrix) {\n            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n            v.multiplyScalar(-distance);\n\n            panOffset.add(v);\n        };\n    })();\n\n    var panUp = (function () {\n        var v = new Vector3();\n\n        return function panUp(distance, objectMatrix) {\n            if (scope.screenSpacePanning === true) {\n                v.setFromMatrixColumn(objectMatrix, 1);\n            } else {\n                v.setFromMatrixColumn(objectMatrix, 0);\n                v.crossVectors(scope.object.up, v);\n            }\n\n            v.multiplyScalar(distance);\n\n            panOffset.add(v);\n        };\n    })();\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    var pan = (function () {\n        var offset = new Vector3();\n\n        return function pan(deltaX, deltaY) {\n            var element = scope.domElement;\n\n            if (scope.object.isPerspectiveCamera) {\n                // perspective\n                var position = scope.object.position;\n                offset.copy(position).sub(scope.target);\n                var targetDistance = offset.length();\n\n                // half of the fov is center to top of screen\n                targetDistance *= Math.tan(\n                    ((scope.object.fov / 2) * Math.PI) / 180.0\n                );\n\n                // we use only clientHeight here so aspect ratio does not distort speed\n                panLeft(\n                    (2 * deltaX * targetDistance) / element.clientHeight,\n                    scope.object.matrix\n                );\n                panUp(\n                    (2 * deltaY * targetDistance) / element.clientHeight,\n                    scope.object.matrix\n                );\n            } else if (scope.object.isOrthographicCamera) {\n                // orthographic\n                panLeft(\n                    (deltaX * (scope.object.right - scope.object.left)) /\n                        scope.object.zoom /\n                        element.clientWidth,\n                    scope.object.matrix\n                );\n                panUp(\n                    (deltaY * (scope.object.top - scope.object.bottom)) /\n                        scope.object.zoom /\n                        element.clientHeight,\n                    scope.object.matrix\n                );\n            } else {\n                // camera neither orthographic nor perspective\n                console.warn(\n                    \"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\"\n                );\n                scope.enablePan = false;\n            }\n        };\n    })();\n\n    function dollyOut(dollyScale) {\n        if (scope.object.isPerspectiveCamera) {\n            scale /= dollyScale;\n        } else if (scope.object.isOrthographicCamera) {\n            scope.object.zoom = Math.max(\n                scope.minZoom,\n                Math.min(scope.maxZoom, scope.object.zoom * dollyScale)\n            );\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n        } else {\n            console.warn(\n                \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"\n            );\n            scope.enableZoom = false;\n        }\n    }\n\n    function dollyIn(dollyScale) {\n        if (scope.object.isPerspectiveCamera) {\n            scale *= dollyScale;\n        } else if (scope.object.isOrthographicCamera) {\n            scope.object.zoom = Math.max(\n                scope.minZoom,\n                Math.min(scope.maxZoom, scope.object.zoom / dollyScale)\n            );\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n        } else {\n            console.warn(\n                \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"\n            );\n            scope.enableZoom = false;\n        }\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event) {\n        rotateStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownDolly(event) {\n        dollyStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownPan(event) {\n        panStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseMoveRotate(event) {\n        rotateEnd.set(event.clientX, event.clientY);\n\n        rotateDelta\n            .subVectors(rotateEnd, rotateStart)\n            .multiplyScalar(scope.rotateSpeed);\n\n        var element = scope.domElement;\n\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n        rotateStart.copy(rotateEnd);\n\n        scope.update();\n    }\n\n    function handleMouseMoveDolly(event) {\n        dollyEnd.set(event.clientX, event.clientY);\n\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n            dollyOut(getZoomScale());\n        } else if (dollyDelta.y < 0) {\n            dollyIn(getZoomScale());\n        }\n\n        dollyStart.copy(dollyEnd);\n\n        scope.update();\n    }\n\n    function handleMouseMovePan(event) {\n        panEnd.set(event.clientX, event.clientY);\n\n        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n        pan(panDelta.x, panDelta.y);\n\n        panStart.copy(panEnd);\n\n        scope.update();\n    }\n\n    function handleMouseUp(/*event*/) {\n        // no-op\n    }\n\n    function handleMouseWheel(event) {\n        if (event.deltaY < 0) {\n            dollyIn(getZoomScale());\n        } else if (event.deltaY > 0) {\n            dollyOut(getZoomScale());\n        }\n\n        scope.update();\n    }\n\n    function handleKeyDown(event) {\n        var needsUpdate = false;\n\n        switch (event.keyCode) {\n            case scope.keys.UP:\n                pan(0, scope.keyPanSpeed);\n                needsUpdate = true;\n                break;\n\n            case scope.keys.BOTTOM:\n                pan(0, -scope.keyPanSpeed);\n                needsUpdate = true;\n                break;\n\n            case scope.keys.LEFT:\n                pan(scope.keyPanSpeed, 0);\n                needsUpdate = true;\n                break;\n\n            case scope.keys.RIGHT:\n                pan(-scope.keyPanSpeed, 0);\n                needsUpdate = true;\n                break;\n            default:\n                console.log(`Unhandled key: ${event.keyCode}`);\n                break;\n        }\n\n        if (needsUpdate) {\n            // prevent the browser from scrolling on cursor keys\n            event.preventDefault();\n\n            scope.update();\n        }\n    }\n\n    function handleTouchStartRotate(event) {\n        if (event.touches.length === 1) {\n            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        } else {\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n            rotateStart.set(x, y);\n        }\n    }\n\n    function handleTouchStartPan(event) {\n        if (event.touches.length === 1) {\n            panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        } else {\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n            panStart.set(x, y);\n        }\n    }\n\n    function handleTouchStartDolly(event) {\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        dollyStart.set(0, distance);\n    }\n\n    function handleTouchStartDollyPan(event) {\n        if (scope.enableZoom) handleTouchStartDolly(event);\n\n        if (scope.enablePan) handleTouchStartPan(event);\n    }\n\n    function handleTouchStartDollyRotate(event) {\n        if (scope.enableZoom) handleTouchStartDolly(event);\n\n        if (scope.enableRotate) handleTouchStartRotate(event);\n    }\n\n    function handleTouchMoveRotate(event) {\n        if (event.touches.length === 1) {\n            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        } else {\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n            rotateEnd.set(x, y);\n        }\n\n        rotateDelta\n            .subVectors(rotateEnd, rotateStart)\n            .multiplyScalar(scope.rotateSpeed);\n\n        var element = scope.domElement;\n\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n        rotateStart.copy(rotateEnd);\n    }\n\n    function handleTouchMovePan(event) {\n        if (event.touches.length === 1) {\n            panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        } else {\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n            panEnd.set(x, y);\n        }\n\n        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n        pan(panDelta.x, panDelta.y);\n\n        panStart.copy(panEnd);\n    }\n\n    function handleTouchMoveDolly(event) {\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        dollyEnd.set(0, distance);\n\n        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n        dollyOut(dollyDelta.y);\n\n        dollyStart.copy(dollyEnd);\n    }\n\n    function handleTouchMoveDollyPan(event) {\n        if (scope.enableZoom) handleTouchMoveDolly(event);\n\n        if (scope.enablePan) handleTouchMovePan(event);\n    }\n\n    function handleTouchMoveDollyRotate(event) {\n        if (scope.enableZoom) handleTouchMoveDolly(event);\n\n        if (scope.enableRotate) handleTouchMoveRotate(event);\n    }\n\n    function handleTouchEnd(/*event*/) {\n        // no-op\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event) {\n        if (scope.enabled === false) return;\n\n        switch (event.pointerType) {\n            case \"mouse\":\n            case \"pen\":\n                onMouseDown(event);\n                break;\n            default:\n                console.log(`Unhandled key: ${event}`);\n                break;\n        }\n    }\n\n    function onPointerMove(event) {\n        if (scope.enabled === false) return;\n\n        switch (event.pointerType) {\n            case \"mouse\":\n            case \"pen\":\n                onMouseMove(event);\n                break;\n            default:\n                console.log(`Unhandled key: ${event}`);\n                break;\n        }\n    }\n\n    function onPointerUp(event) {\n        switch (event.pointerType) {\n            case \"mouse\":\n            case \"pen\":\n                onMouseUp(event);\n                break;\n            default:\n                console.log(`Unhandled key: ${event}`);\n                break;\n        }\n    }\n\n    function onMouseDown(event) {\n        // Prevent the browser from scrolling.\n        event.preventDefault();\n\n        // Manually set the focus since calling preventDefault above\n        // prevents the browser from setting it automatically.\n\n        scope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n        var mouseAction;\n\n        switch (event.button) {\n            case 0:\n                mouseAction = scope.mouseButtons.LEFT;\n                break;\n\n            case 1:\n                mouseAction = scope.mouseButtons.MIDDLE;\n                break;\n\n            case 2:\n                mouseAction = scope.mouseButtons.RIGHT;\n                break;\n\n            default:\n                mouseAction = -1;\n        }\n\n        switch (mouseAction) {\n            case MOUSE.DOLLY:\n                if (scope.enableZoom === false) return;\n\n                handleMouseDownDolly(event);\n\n                state = STATE.DOLLY;\n\n                break;\n\n            case MOUSE.ROTATE:\n                if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                    if (scope.enablePan === false) return;\n\n                    handleMouseDownPan(event);\n\n                    state = STATE.PAN;\n                } else {\n                    if (scope.enableRotate === false) return;\n\n                    handleMouseDownRotate(event);\n\n                    state = STATE.ROTATE;\n                }\n\n                break;\n\n            case MOUSE.PAN:\n                if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                    if (scope.enableRotate === false) return;\n\n                    handleMouseDownRotate(event);\n\n                    state = STATE.ROTATE;\n                } else {\n                    if (scope.enablePan === false) return;\n\n                    handleMouseDownPan(event);\n\n                    state = STATE.PAN;\n                }\n\n                break;\n\n            default:\n                state = STATE.NONE;\n        }\n\n        if (state !== STATE.NONE) {\n            scope.domElement.ownerDocument.addEventListener(\n                \"pointermove\",\n                onPointerMove,\n                false\n            );\n            scope.domElement.ownerDocument.addEventListener(\n                \"pointerup\",\n                onPointerUp,\n                false\n            );\n\n            scope.dispatchEvent(startEvent);\n        }\n    }\n\n    function onMouseMove(event) {\n        if (scope.enabled === false) return;\n\n        event.preventDefault();\n\n        switch (state) {\n            case STATE.ROTATE:\n                if (scope.enableRotate === false) return;\n                handleMouseMoveRotate(event);\n                break;\n            case STATE.DOLLY:\n                if (scope.enableZoom === false) return;\n                handleMouseMoveDolly(event);\n                break;\n            case STATE.PAN:\n                if (scope.enablePan === false) return;\n                handleMouseMovePan(event);\n                break;\n            default:\n                console.log(`Unhandled key: ${event.keyCode}`);\n                break;\n        }\n    }\n\n    function onMouseUp(event) {\n        scope.domElement.ownerDocument.removeEventListener(\n            \"pointermove\",\n            onPointerMove,\n            false\n        );\n        scope.domElement.ownerDocument.removeEventListener(\n            \"pointerup\",\n            onPointerUp,\n            false\n        );\n\n        if (scope.enabled === false) return;\n\n        handleMouseUp(event);\n\n        scope.dispatchEvent(endEvent);\n\n        state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n        if (\n            scope.enabled === false ||\n            scope.enableZoom === false ||\n            (state !== STATE.NONE && state !== STATE.ROTATE)\n        )\n            return;\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        scope.dispatchEvent(startEvent);\n\n        handleMouseWheel(event);\n\n        scope.dispatchEvent(endEvent);\n    }\n\n    function onKeyDown(event) {\n        if (\n            scope.enabled === false ||\n            scope.enableKeys === false ||\n            scope.enablePan === false\n        )\n            return;\n\n        handleKeyDown(event);\n    }\n\n    function onTouchStart(event) {\n        if (scope.enabled === false) return;\n\n        event.preventDefault(); // prevent scrolling\n\n        switch (event.touches.length) {\n            case 1:\n                switch (scope.touches.ONE) {\n                    case TOUCH.ROTATE:\n                        if (scope.enableRotate === false) return;\n\n                        handleTouchStartRotate(event);\n\n                        state = STATE.TOUCH_ROTATE;\n\n                        break;\n\n                    case TOUCH.PAN:\n                        if (scope.enablePan === false) return;\n\n                        handleTouchStartPan(event);\n\n                        state = STATE.TOUCH_PAN;\n\n                        break;\n\n                    default:\n                        state = STATE.NONE;\n                }\n\n                break;\n\n            case 2:\n                switch (scope.touches.TWO) {\n                    case TOUCH.DOLLY_PAN:\n                        if (\n                            scope.enableZoom === false &&\n                            scope.enablePan === false\n                        )\n                            return;\n\n                        handleTouchStartDollyPan(event);\n\n                        state = STATE.TOUCH_DOLLY_PAN;\n\n                        break;\n\n                    case TOUCH.DOLLY_ROTATE:\n                        if (\n                            scope.enableZoom === false &&\n                            scope.enableRotate === false\n                        )\n                            return;\n\n                        handleTouchStartDollyRotate(event);\n\n                        state = STATE.TOUCH_DOLLY_ROTATE;\n\n                        break;\n\n                    default:\n                        state = STATE.NONE;\n                }\n\n                break;\n\n            default:\n                state = STATE.NONE;\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n    }\n\n    function onTouchMove(event) {\n        if (scope.enabled === false) return;\n\n        event.preventDefault(); // prevent scrolling\n        event.stopPropagation();\n\n        switch (state) {\n            case STATE.TOUCH_ROTATE:\n                if (scope.enableRotate === false) return;\n\n                handleTouchMoveRotate(event);\n\n                scope.update();\n\n                break;\n\n            case STATE.TOUCH_PAN:\n                if (scope.enablePan === false) return;\n\n                handleTouchMovePan(event);\n\n                scope.update();\n\n                break;\n\n            case STATE.TOUCH_DOLLY_PAN:\n                if (scope.enableZoom === false && scope.enablePan === false)\n                    return;\n\n                handleTouchMoveDollyPan(event);\n\n                scope.update();\n\n                break;\n\n            case STATE.TOUCH_DOLLY_ROTATE:\n                if (scope.enableZoom === false && scope.enableRotate === false)\n                    return;\n\n                handleTouchMoveDollyRotate(event);\n\n                scope.update();\n\n                break;\n\n            default:\n                state = STATE.NONE;\n        }\n    }\n\n    function onTouchEnd(event) {\n        if (scope.enabled === false) return;\n\n        handleTouchEnd(event);\n\n        scope.dispatchEvent(endEvent);\n\n        state = STATE.NONE;\n    }\n\n    function onContextMenu(event) {\n        if (scope.enabled === false) return;\n\n        event.preventDefault();\n    }\n\n    //\n\n    scope.domElement.addEventListener(\"contextmenu\", onContextMenu, false);\n\n    scope.domElement.addEventListener(\"pointerdown\", onPointerDown, false);\n    scope.domElement.addEventListener(\"wheel\", onMouseWheel, false);\n\n    scope.domElement.addEventListener(\"touchstart\", onTouchStart, false);\n    scope.domElement.addEventListener(\"touchend\", onTouchEnd, false);\n    scope.domElement.addEventListener(\"touchmove\", onTouchMove, false);\n\n    scope.domElement.addEventListener(\"keydown\", onKeyDown, false);\n\n    // force an update at start\n\n    this.update();\n};\n\nOrbitControls.prototype = Object.create(EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nvar MapControls = function (object, domElement) {\n    OrbitControls.call(this, object, domElement);\n\n    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN;\n    this.mouseButtons.RIGHT = MOUSE.ROTATE;\n\n    this.touches.ONE = TOUCH.PAN;\n    this.touches.TWO = TOUCH.DOLLY_ROTATE;\n};\n\nMapControls.prototype = Object.create(EventDispatcher.prototype);\nMapControls.prototype.constructor = MapControls;\n\nexport { OrbitControls, MapControls };\n","import * as THREE from 'three';\n\n/**\n * Enum for the axes in three dimensional space,\n * both positive and negative.\n *\n * Positive values correspond to the keys for\n * THREE.Vector3 vectors.\n */\nexport const Axes = Object.freeze({\n    POSITIVE: {\n        X: \"x\",\n        Y: \"y\",\n        Z: \"z\",\n    },\n    NEGATIVE: {\n        X: \"-x\",\n        Y: \"-y\",\n        Z: \"-z\",\n    },\n});\n\n/**\n * Normalized axis vectors corresponding to the three axes in either direction.\n */\nexport const AxisVectors = Object.freeze({\n    [Axes.POSITIVE.X]: new THREE.Vector3(1, 0, 0),\n    [Axes.POSITIVE.Y]: new THREE.Vector3(0, 1, 0),\n    [Axes.POSITIVE.Z]: new THREE.Vector3(0, 0, 1),\n    [Axes.NEGATIVE.X]: new THREE.Vector3(-1, 0, 0),\n    [Axes.NEGATIVE.Y]: new THREE.Vector3(0, -1, 0),\n    [Axes.NEGATIVE.Z]: new THREE.Vector3(0, 0, -1),\n});\n\n/**\n * Constant controlling speed of animations.\n */\nexport const ANIMATION_SPEED = 12.5;\n\n/**\n * Constants in the move buffer to signal the start and end of a solution\n */\nexport const MoveFlags = Object.freeze({\n    SOLUTION_START: \"start\",\n    SOLUTION_END: \"end\",\n});\n\n/**\n * Constants for click events to control what happens during mouse actions\n */\nexport const ClickFlags = Object.freeze({\n    NONE: \"none\",\n    ROTATION: \"rotation\",\n    CUBIE: \"cubie\",\n});\n\n/**\n * Map from key presses to the moves they correspond to.\n */\nexport const KeysToMoves = Object.freeze({\n    u: \"U\",\n    d: \"D\",\n    f: \"F\",\n    b: \"B\",\n    r: \"R\",\n    l: \"L\",\n    m: \"M\",\n    e: \"E\",\n    s: \"S\",\n    x: \"X\",\n    y: \"Y\",\n    z: \"Z\",\n    U: \"U'\",\n    D: \"D'\",\n    F: \"F'\",\n    B: \"B'\",\n    R: \"R'\",\n    L: \"L'\",\n    M: \"M'\",\n    E: \"E'\",\n    S: \"S'\",\n    X: \"X'\",\n    Y: \"Y'\",\n    Z: \"Z'\",\n    wu: \"u\",\n    wd: \"d\",\n    wf: \"f\",\n    wb: \"b\",\n    wr: \"r\",\n    wl: \"l\",\n    wU: \"u'\",\n    wD: \"d'\",\n    wF: \"f'\",\n    wB: \"b'\",\n    wR: \"r'\",\n    wL: \"l'\",\n});\n","import * as THREE from 'three';\n\nimport { Axes } from \"./Constants.js\";\n\n/**\n * Rotation matrices to rotate the THREE.Vector3 about an axis by\n * a given angle.\n *\n * See: https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n * for more info on rotation matrices.\n */\n\n/**\n * Get a rotation matrix to rotate on the X-axis\n * by theta radians.\n */\nfunction getXRotationMatrix(theta) {\n    const m = new THREE.Matrix3();\n    m.set(\n        1,\n        0,\n        0,\n        0,\n        Math.cos(theta),\n        -Math.sin(theta),\n        0,\n        Math.sin(theta),\n        Math.cos(theta)\n    );\n    return m;\n}\n\n/**\n * Get a rotation matrix to rotate on the Y-axis\n * by theta radians.\n */\nfunction getYRotationMatrix(theta) {\n    const m = new THREE.Matrix3();\n    m.set(\n        Math.cos(theta),\n        0,\n        Math.sin(theta),\n        0,\n        1,\n        0,\n        -Math.sin(theta),\n        0,\n        Math.cos(theta)\n    );\n    return m;\n}\n\n/**\n * Get a rotation matrix to rotate on the Z-axis\n * by theta radians.\n */\nfunction getZRotationMatrix(theta) {\n    const m = new THREE.Matrix3();\n    m.set(\n        Math.cos(theta),\n        -Math.sin(theta),\n        0,\n        Math.sin(theta),\n        Math.cos(theta),\n        0,\n        0,\n        0,\n        1\n    );\n    return m;\n}\n\n/**\n * Array of rotation matrices, one per axis.\n */\nconst rotationMatrices = [\n    getXRotationMatrix,\n    getYRotationMatrix,\n    getZRotationMatrix,\n];\n\n/**\n * Map from axis to index into rotationMatrices array.\n */\nconst axisEnum = Object.freeze({\n    [Axes.POSITIVE.X]: 0,\n    [Axes.POSITIVE.Y]: 1,\n    [Axes.POSITIVE.Z]: 2,\n});\n\n/**\n * Get a rotation matrix for the given axis (\"x\", \"y\", or \"z\")\n * for the given number of radians.\n */\nexport default function getRotationMatrix(axis, theta) {\n    return rotationMatrices[axisEnum[axis]](theta);\n}\n","import * as THREE from 'three';\n\nimport getRotationMatrix from \"./RotationMatrices.js\";\nimport { Axes, AxisVectors } from \"./Constants.js\";\n\n/**\n * Rounded Rectangle code taken from three.js examples: https://threejs.org/examples/#webgl_geometry_shapes\n */\n// create a new shape and manually construct a rounded square\nconst shape = new THREE.Shape();\nconst pos = 0; // the initial x and y coordinate of the square\nconst size = 0.925; // side length of the rounded square\nconst radius = 0.1; // radius of the curves in the corners of the square\n// draw left side\nshape.moveTo(pos, pos + radius);\nshape.lineTo(pos, pos + size - radius);\n// curve and draw top side\nshape.quadraticCurveTo(pos, pos + size, pos + radius, pos + size);\nshape.lineTo(pos + size - radius, pos + size);\n// curve and draw right side\nshape.quadraticCurveTo(pos + size, pos + size, pos + size, pos + size - radius);\nshape.lineTo(pos + size, pos + radius);\n// curve and draw bottom side\nshape.quadraticCurveTo(pos + size, pos, pos + size - radius, pos);\nshape.lineTo(pos + radius, pos);\n// draw final curve connecting to left side\nshape.quadraticCurveTo(pos, pos, pos, pos + radius);\n\n// create a geometry from the rounded square shape\nconst roundedSquareGeometry = new THREE.ShapeBufferGeometry(shape);\nroundedSquareGeometry.center();\n\n/**\n * Class for an individual sticker on the cube.\n */\nclass Sticker {\n    /**\n     * Construct a new sticker at the given position facing the given\n     * direction with the specified video URL.\n     * @param {number} x X position of sticker\n     * @param {number} y Y position of sticker\n     * @param {number} z Z position of sticker\n     * @param {*} facingVector Direction sticker is facing\n     * @param {string} videoURL Video URL for the sticker\n     */\n    constructor(x, y, z, facingVector, videoURL) {\n        this.positionVector = new THREE.Vector3(x, y, z);\n        this.fixedPositionVector = new THREE.Vector3(x, y, z);\n        this.facingVector = facingVector;\n        this.fixedFacingVector = new THREE.Vector3(facingVector.x, facingVector.y, facingVector.z);\n\n        // Setup video element\n        const video = document.createElement('video');\n        video.crossOrigin = \"anonymous\";\n        video.src = videoURL;\n        video.load();\n        video.muted = true;\n        video.loop = true;\n        video.play().catch(e => console.error(\"Autoplay was prevented:\", e)); // Handle autoplay issues gracefully\n\n        // Create a video texture from the video element\n        const texture = new THREE.VideoTexture(video);\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        texture.format = THREE.RGBFormat;\n\n        // Use the video texture for the material\n        this.material = new THREE.MeshBasicMaterial({\n            map: texture,\n            side: THREE.DoubleSide,\n        });\n\n        // Use the rounded square geometry for the mesh\n        this.mesh = new THREE.Mesh(roundedSquareGeometry, this.material);\n\n        // Set initial position and rotation\n        this.updatePosition(this.fixedPositionVector, this.fixedFacingVector);\n        this.mesh.rotation.y = Math.PI * 0.5 * Math.abs(this.facingVector.x);\n        this.mesh.rotation.x = Math.PI * 0.5 * Math.abs(this.facingVector.y);\n    }\n    \n    /**\n     * Update the position of the sticker based on the new position and facing direction.\n     * @param {*} positionVector new position\n     * @param {*} facingVector new facing direction\n     */\n    updatePosition(positionVector, facingVector) {\n        // this.mesh.position is the actual position of the face\n        // it is defined as the positionVector translated by the facingVector\n        this.mesh.position.x = positionVector.x + 0.5 * facingVector.x;\n        this.mesh.position.y = positionVector.y + 0.5 * facingVector.y;\n        this.mesh.position.z = positionVector.z + 0.5 * facingVector.z;\n        // translate slightly further so the sticker appears above the cubie's surface\n        this.mesh.position.x += this.mesh.position.x > 0 ? 0.001 : -0.001;\n        this.mesh.position.y += this.mesh.position.y > 0 ? 0.001 : -0.001;\n        this.mesh.position.z += this.mesh.position.z > 0 ? 0.001 : -0.001;\n\n        const axes = Object.values(Axes.POSITIVE);\n        axes.forEach((axis) => {\n            // find the axis the sticker is currently facing\n            if (\n                positionVector[axis] === facingVector[axis] &&\n                Math.abs(positionVector[axis]) === 1\n            ) {\n                // for the other two axes\n                for (const rest of axes.filter((elt) => elt !== axis)) {\n                    // translate slightly inward on that axis (if non-zero)\n                    // this centers the sticker on the cubie\n                    if (positionVector[rest] === 1) {\n                        this.mesh.position[rest] -= 0.025;\n                    } else if (positionVector[rest] === -1) {\n                        this.mesh.position[rest] += 0.025;\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * \"Lock\" position in place. To be called when a turn is complete.\n     *\n     * Assumes the fixed vectors are correct and updates the mesh's position\n     * and all other vectors to reflect that\n     */\n    lockPosition() {\n        // update position vectors\n        const x = Math.round(this.fixedPositionVector.x);\n        const y = Math.round(this.fixedPositionVector.y);\n        const z = Math.round(this.fixedPositionVector.z);\n        this.positionVector = new THREE.Vector3(x, y, z);\n        this.fixedPositionVector = new THREE.Vector3(x, y, z);\n\n        // update facing vectors\n        this.facingVector = new THREE.Vector3(\n            Math.round(this.fixedFacingVector.x),\n            Math.round(this.fixedFacingVector.y),\n            Math.round(this.fixedFacingVector.z)\n        );\n        this.fixedFacingVector = new THREE.Vector3(\n            this.facingVector.x,\n            this.facingVector.y,\n            this.facingVector.z\n        );\n\n        // set mesh's rotation\n        this.mesh.rotation.y = Math.PI * 0.5 * Math.abs(this.facingVector.x);\n        this.mesh.rotation.x = Math.PI * 0.5 * Math.abs(this.facingVector.y);\n        this.mesh.rotation.z = 0;\n    }\n    // perform instantaneous 90 degree turn\n    turn(axis, dir) {\n        var rotationMatrix = getRotationMatrix(axis, dir * Math.PI * 0.5);\n        this.fixedFacingVector.applyMatrix3(rotationMatrix);\n        this.fixedPositionVector.applyMatrix3(rotationMatrix);\n        this.lockPosition();\n        this.updatePosition(this.fixedPositionVector, this.fixedFacingVector);\n        this.mesh.rotation.y = Math.PI * 0.5 * Math.abs(this.facingVector.x);\n        this.mesh.rotation.x = Math.PI * 0.5 * Math.abs(this.facingVector.y);\n    }\n    // perform a rotation of theta radians\n    rotate(axis, theta) {\n        var rotationMatrix = getRotationMatrix(axis, theta);\n        this.facingVector.applyMatrix3(rotationMatrix);\n        this.positionVector.applyMatrix3(rotationMatrix);\n        this.updatePosition(this.positionVector, this.facingVector);\n        this.mesh.rotateOnWorldAxis(AxisVectors[axis], theta);\n    }\n}\n\nexport default Sticker;\n","import * as THREE from 'three';\n\nimport getRotationMatrix from \"./RotationMatrices.js\";\nimport Sticker from \"./Sticker.js\";\n\n/**\n * Rounded Box code taken from forum: https://discourse.threejs.org/t/round-edged-box/1402\n */\nconst width = 1; // width of box\nconst height = 1; // height of box\nconst depth = 1; // depth of box\nconst radius0 = 0.05; // radius of curve\nconst smoothness = 16; // smoothness of curve\n\n// create a rounded box shape\nconst shape = new THREE.Shape();\nconst eps = 0.00001;\nconst radius = radius0 - eps;\nshape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\nshape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\nshape.absarc(\n    width - radius * 2,\n    height - radius * 2,\n    eps,\n    Math.PI / 2,\n    0,\n    true\n);\nshape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n\n// create the geometry based on the shape\nconst roundedBoxGeometry = new THREE.ExtrudeBufferGeometry(shape, {\n    depth: depth - radius0 * 2,\n    bevelEnabled: true,\n    bevelSegments: smoothness * 2,\n    steps: 1,\n    bevelSize: radius,\n    bevelThickness: radius0,\n    curveSegments: smoothness,\n});\nroundedBoxGeometry.center();\n\n// basic black material for the cubie\nconst materialBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });\n\n/**\n * Class for each cubie on the cube\n */\nclass Cubie {\n    constructor(x, y, z, cubieVideoURLs) { // Now accepts cubieVideoURLs\n        this.angle = 0;\n        this.animating = false;\n        this.animateAxis = null;\n        this.animateDir = 0;\n\n        this.positionVector = new THREE.Vector3(x, y, z);\n        this.fixedPositionVector = new THREE.Vector3(x, y, z);\n\n        this.mesh = new THREE.Mesh(roundedBoxGeometry, materialBlack);\n        this.stickers = [];\n\n        let videoIndex = 0; // To iterate over cubieVideoURLs\n\n        if (x === -1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(-1, 0, 0), cubieVideoURLs[videoIndex++]));\n        } else if (x === 1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(1, 0, 0), cubieVideoURLs[videoIndex++]));\n        }\n        if (y === -1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(0, -1, 0), cubieVideoURLs[videoIndex++]));\n        } else if (y === 1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(0, 1, 0), cubieVideoURLs[videoIndex++]));\n        }\n        if (z === -1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(0, 0, -1), cubieVideoURLs[videoIndex++]));\n        } else if (z === 1) {\n            this.stickers.push(new Sticker(x, y, z, new THREE.Vector3(0, 0, 1), cubieVideoURLs[videoIndex++]));\n        }\n\n        this.updatePosition(this.fixedPositionVector);\n    }\n\n    /**\n     * Update the mesh's position\n     * @param {*} vector new position\n     */\n    updatePosition(vector) {\n        this.mesh.position.x = vector.x;\n        this.mesh.position.y = vector.y;\n        this.mesh.position.z = vector.z;\n    }\n\n    /**\n     * \"Lock\" position in place. To be called when a turn is complete.\n     *\n     * Assumes fixed position vector is the correct position and updates the\n     * mesh's actual position to reflect that\n     */\n    lockPosition() {\n        const x = Math.round(this.fixedPositionVector.x);\n        const y = Math.round(this.fixedPositionVector.y);\n        const z = Math.round(this.fixedPositionVector.z);\n        this.positionVector = new THREE.Vector3(x, y, z);\n        this.fixedPositionVector = new THREE.Vector3(x, y, z);\n\n        this.mesh.position.x = x;\n        this.mesh.position.y = y;\n        this.mesh.position.z = z;\n        this.stickers.forEach((sticker) => {\n            sticker.lockPosition();\n        });\n    }\n\n    /**\n     * Perform an instantaneous 90 degree turn about the given axis in the specified direction.\n     * @param {*} axis axis about which to perform the turn\n     * @param {*} dir direction in which to perform the turn\n     */\n    turn(axis, dir) {\n        var rotationMatrix = getRotationMatrix(axis, dir * Math.PI * 0.5);\n        this.fixedPositionVector.applyMatrix3(rotationMatrix);\n        this.lockPosition();\n        this.updatePosition(this.fixedPositionVector); // TODO: remove this?\n        this.mesh.rotation.x = 0;\n        this.mesh.rotation.y = 0;\n        this.mesh.rotation.z = 0;\n        this.stickers.forEach((sticker) => {\n            sticker.turn(axis, dir);\n        });\n    }\n\n    /**\n     * Rotate the cubie the specified number of radians about the given axis\n     * @param {*} axis axis about which to perform the rotation\n     * @param {*} theta radians to rotate by\n     */\n    rotate(axis, theta) {\n        // get the rotation matrix corresponding to the requested rotation\n        const rotationMatrix = getRotationMatrix(axis, theta);\n        // apply rotation to the position vector\n        this.positionVector.applyMatrix3(rotationMatrix);\n        // update cubie's position\n        this.updatePosition(this.positionVector);\n        // increment mesh's rotation\n        this.mesh.rotation[axis] += theta;\n\n        // rotate each sticker as well\n        this.stickers.forEach((sticker) => {\n            sticker.rotate(axis, theta);\n        });\n    }\n}\n\nexport default Cubie;\n","import Cubie from \"./Cubie.js\";\nimport { Axes } from \"./Constants.js\";\n\n/**\n * Class to store the meshes for the cubies and stickers comprising a Rubik's Cube.\n */\nclass Cube {\n    /**\n     * Construct a new cube.\n     * @param {*} scene threejs scene the cube is a part of\n     */\n    constructor(scene, videoURLs) {\n        // array to store every Cubie object\n        this.cubies = [];\n        // array to store all the meshes comprising the cube\n        this.meshes = [];\n        // map from sticker's mesh uuid to the mesh itself\n        this.stickersMap = new Map();\n\n        this.videoURLs = videoURLs; // Store video URLs\n\n        // Assuming videoURLs is an array of at least 54 video URLs.\n        let videoIndex = 0; // To keep track of the current video URL index\n\n        // initialize 26 cubies (ignoring the very center)\n        for (let x = -1; x <= 1; x++) {\n            for (let y = -1; y <= 1; y++) {\n                for (let z = -1; z <= 1; z++) {\n                    if (x !== 0 || y !== 0 || z !== 0) {\n                        // Pass an array of video URLs for each Cubie's stickers\n                        // This assumes each Cubie knows how to assign these URLs to its stickers\n                        const cubieVideoURLs = this.videoURLs.slice(videoIndex, videoIndex + 3);\n                        this.cubies.push(new Cubie(x, y, z, cubieVideoURLs));\n                        videoIndex += 3; // Advance the index by 3 for the next Cubie\n                    }\n                }\n            }\n        }\n        // for each cubie\n        this.cubies.forEach((cubie) => {\n            // add it to the scene\n            scene.add(cubie.mesh);\n            // add cubie's mesh to mesh array\n            this.meshes.push(cubie.mesh);\n            // for each sticker on the cubie\n            cubie.stickers.forEach((sticker) => {\n                // add sticker to scene, mesh array, and stickers map\n                scene.add(sticker.mesh);\n                this.meshes.push(sticker.mesh);\n                this.stickersMap.set(sticker.mesh.uuid, sticker);\n            });\n        });\n    }\n\n    /**\n     * Perform a given function on every cubie in the cube.\n     * @param {*} fn function to perform on each cubie\n     */\n    forEach(fn) {\n        this.cubies.forEach((cubie) => {\n            fn(cubie);\n        });\n    }\n\n    /**\n     * Generate and return a unique string representation of the cube state.\n     * @returns string representation of the cube state\n     */\n    repr() {\n        // first figure out what stickers are where by examining the cubies array\n\n        // stickers[face][x][y] = sticker at x, y on that face,\n        // where faces are ordered up, down, front, back, right, left\n        const stickers = [\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n            [\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n                [\"B\", \"B\", \"B\"],\n            ],\n        ];\n        // for each cubie, store its face color\n        this.cubies.forEach((cubie) => {\n            // up face\n            if (cubie.positionVector.y === 1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.y === 1)\n                        stickers[0][sticker.fixedPositionVector.z + 1][\n                            sticker.fixedPositionVector.x + 1\n                        ] = sticker.getColor();\n                });\n            }\n            // down face\n            if (cubie.positionVector.y === -1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.y === -1) {\n                        stickers[1][-1 * sticker.fixedPositionVector.z + 1][\n                            sticker.fixedPositionVector.x + 1\n                        ] = sticker.getColor();\n                    }\n                });\n            }\n            // front face\n            if (cubie.positionVector.z === 1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.z === 1)\n                        stickers[2][-1 * sticker.fixedPositionVector.y + 1][\n                            sticker.fixedPositionVector.x + 1\n                        ] = sticker.getColor();\n                });\n            }\n            // back face\n            if (cubie.positionVector.z === -1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.z === -1)\n                        stickers[3][-1 * sticker.fixedPositionVector.y + 1][\n                            -1 * sticker.fixedPositionVector.x + 1\n                        ] = sticker.getColor();\n                });\n            }\n            // right face\n            if (cubie.positionVector.x === 1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.x === 1)\n                        stickers[4][-1 * sticker.fixedPositionVector.y + 1][\n                            -1 * sticker.fixedPositionVector.z + 1\n                        ] = sticker.getColor();\n                });\n            }\n            // left face\n            if (cubie.positionVector.x === -1) {\n                cubie.stickers.forEach((sticker) => {\n                    if (sticker.facingVector.x === -1)\n                        stickers[5][-1 * sticker.fixedPositionVector.y + 1][\n                            sticker.fixedPositionVector.z + 1\n                        ] = sticker.getColor();\n                });\n            }\n        });\n\n        // construct the repr from the extracted stickers data\n        let cubeRepr = \"\";\n        stickers.forEach((sticker) => {\n            sticker.forEach((line) => {\n                cubeRepr += line.join(\"\");\n            });\n        });\n\n        return cubeRepr;\n    }\n\n    /**\n     * Initiate the animation for the requested move.\n     *\n     * The move string should correspond to standard cube notation.\n     *\n     * @param {string} moveStr Move to perform\n     */\n    move(moveStr) {\n        switch (moveStr) {\n            case \"U\":\n                this.moveLayer(Axes.POSITIVE.Y, 1, 1);\n                return;\n            case \"U'\":\n                this.moveLayer(Axes.POSITIVE.Y, 1, -1);\n                return;\n            case \"u\":\n                this.moveLayer(Axes.POSITIVE.Y, 1, 1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, -1);\n                return;\n            case \"u'\":\n                this.moveLayer(Axes.POSITIVE.Y, 1, -1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, 1);\n                return;\n            case \"D\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, 1);\n                return;\n            case \"D'\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, -1);\n                return;\n            case \"d\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, 1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, 1);\n                return;\n            case \"d'\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, -1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, -1);\n                return;\n            case \"F\":\n                this.moveLayer(Axes.POSITIVE.Z, 1, 1);\n                return;\n            case \"F'\":\n                this.moveLayer(Axes.POSITIVE.Z, 1, -1);\n                return;\n            case \"f\":\n                this.moveLayer(Axes.POSITIVE.Z, 1, 1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, 1);\n                return;\n            case \"f'\":\n                this.moveLayer(Axes.POSITIVE.Z, 1, -1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, -1);\n                return;\n            case \"B\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, 1);\n                return;\n            case \"B'\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, -1);\n                return;\n            case \"b\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, 1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, -1);\n                return;\n            case \"b'\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, -1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, 1);\n                return;\n            case \"R\":\n                this.moveLayer(Axes.POSITIVE.X, 1, 1);\n                return;\n            case \"R'\":\n                this.moveLayer(Axes.POSITIVE.X, 1, -1);\n                return;\n            case \"r\":\n                this.moveLayer(Axes.POSITIVE.X, 1, 1);\n                this.moveLayer(Axes.POSITIVE.X, 0, -1);\n                return;\n            case \"r'\":\n                this.moveLayer(Axes.POSITIVE.X, 1, -1);\n                this.moveLayer(Axes.POSITIVE.X, 0, 1);\n                return;\n            case \"L\":\n                this.moveLayer(Axes.POSITIVE.X, -1, 1);\n                return;\n            case \"L'\":\n                this.moveLayer(Axes.POSITIVE.X, -1, -1);\n                return;\n            case \"l\":\n                this.moveLayer(Axes.POSITIVE.X, -1, 1);\n                this.moveLayer(Axes.POSITIVE.X, 0, 1);\n                return;\n            case \"l'\":\n                this.moveLayer(Axes.POSITIVE.X, -1, -1);\n                this.moveLayer(Axes.POSITIVE.X, 0, -1);\n                return;\n            case \"M\":\n                this.moveLayer(Axes.POSITIVE.X, 0, 1);\n                return;\n            case \"M'\":\n                this.moveLayer(Axes.POSITIVE.X, 0, -1);\n                return;\n            case \"E\":\n                this.moveLayer(Axes.POSITIVE.Y, 0, 1);\n                return;\n            case \"E'\":\n                this.moveLayer(Axes.POSITIVE.Y, 0, -1);\n                return;\n            case \"S\":\n                this.moveLayer(Axes.POSITIVE.Z, 0, 1);\n                return;\n            case \"S'\":\n                this.moveLayer(Axes.POSITIVE.Z, 0, -1);\n                return;\n            case \"x\":\n            case \"X\":\n                this.moveLayer(Axes.POSITIVE.X, -1, -1);\n                this.moveLayer(Axes.POSITIVE.X, 0, -1);\n                this.moveLayer(Axes.POSITIVE.X, 1, 1);\n                return;\n            case \"x'\":\n            case \"X'\":\n                this.moveLayer(Axes.POSITIVE.X, -1, 1);\n                this.moveLayer(Axes.POSITIVE.X, 0, 1);\n                this.moveLayer(Axes.POSITIVE.X, 1, -1);\n                return;\n            case \"y\":\n            case \"Y\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, -1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, -1);\n                this.moveLayer(Axes.POSITIVE.Y, 1, 1);\n                return;\n            case \"y'\":\n            case \"Y'\":\n                this.moveLayer(Axes.POSITIVE.Y, -1, 1);\n                this.moveLayer(Axes.POSITIVE.Y, 0, 1);\n                this.moveLayer(Axes.POSITIVE.Y, 1, -1);\n                return;\n            case \"z\":\n            case \"Z\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, -1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, 1);\n                this.moveLayer(Axes.POSITIVE.Z, 1, 1);\n                return;\n            case \"z'\":\n            case \"Z'\":\n                this.moveLayer(Axes.POSITIVE.Z, -1, 1);\n                this.moveLayer(Axes.POSITIVE.Z, 0, -1);\n                this.moveLayer(Axes.POSITIVE.Z, 1, -1);\n                return;\n            default:\n                console.warn(`Unhandled move: ${moveStr}`);\n                // Handle the unexpected moveStr, e.g., by ignoring it or logging a warning.\n                break;\n        }\n    }\n\n    /**\n     * Initiate the animation for the given layer of the cube.\n     *\n     * dir = -1 indicates a counter clockwise turn, and\n     * dir = 1 indicates a clockwise turn.\n     *\n     * @param {*} axis axis used to identify pieces to turn\n     * @param {*} axisValue sign (-1, 0, or 1) of the axis to identify pieces to turn\n     * @param {*} dir direction (-1 or 1) to turn pieces\n     * @returns a function that triggers the requested outer layer turn\n     */\n    moveLayer(axis, axisValue, dir) {\n        // have axisValue change animDir only if non-zero\n        let animDir = dir;\n        // performing an outer layer turn\n        if (axisValue !== 0) animDir *= -1 * axisValue;\n        // performing a slice move, so the dir is a bit trickier to determine\n        else if (axis === Axes.POSITIVE.Z) {\n            // S slice gets the opposite sign\n            animDir *= -1;\n        }\n\n        // turn all pieces who are positioned in the correct layer\n        this.cubies.forEach((cubie) => {\n            if (cubie.positionVector[axis] === axisValue) {\n                cubie.animating = true;\n                cubie.angle = 0;\n                cubie.animateAxis = axis;\n                cubie.animateDir = animDir;\n            }\n        });\n    }\n}\n\nexport default Cube;\n","import * as THREE from 'three';\nimport { OrbitControls } from \"../three/OrbitControls.js\";\nimport Cube from \"./Cube.js\";\nimport {\n    Axes,\n    KeysToMoves,\n    ClickFlags,\n    MoveFlags,\n    ANIMATION_SPEED,\n} from \"./Constants.js\";\n\n// CubeMasterInit function encapsulates the cube setup to be called with videoURLs\nexport function CubeMasterInit(videoURLs) {\n\n    let holdingW = false;\n    const mouse = new THREE.Vector2();\n    const delta = new THREE.Vector2();\n    const raycaster = new THREE.Raycaster();\n\n    const getHeaderSize = () => {\n        // Height of header for embedding in other websites\n        return 0;\n    };\n\n    const getHeight = () => {\n        // Main content height calculation\n        return window.innerHeight * 1;\n    };\n\n    const getTolerance = () => {\n        // Tolerance for mouse/pointer moves, higher on mobile\n        if (window.innerWidth <= 500) {\n            return 0.1;\n        }\n        return 0.05;\n    };\n\n    let moveBuffer = []; // FIFO buffer for storing moves\n    let animating = false; // Animation state flag\n    let solving = false; // Cube solving state flag\n\n    const domElement = document.getElementById(\"three\"); // Targeting the DOM element for rendering\n\n    const scene = new THREE.Scene(); // Creating a new THREE.js scene\n    scene.background = null; // Setting the scene background color\n\n    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / getHeight(), 0.1, 1000);\n    camera.position.set(4, 4, 6); // Setting camera position\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true }); // Creating the renderer with antialiasing\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, getHeight());\n    domElement.appendChild(renderer.domElement); // Adding the renderer to the DOM\n\n    const controls = new OrbitControls(camera, renderer.domElement); // Configuring orbit controls\n    controls.enablePan = false;\n    controls.enableRotate = false; // Set to true if you want to allow rotation\n    controls.enableZoom = false; // Disable zooming\n    controls.update();\n\n    const cube = new Cube(scene, videoURLs); // Create the cube and pass videoURLs\n\n    let rotationPixelCutoff; // Variable to store cutoff pixel location for changing cube rotations\n\n    // Function to update the rotation pixel cutoff\n    const updateRotationPixelCutoff = () => {\n        const halfWidth = window.innerWidth / 2;\n        cube.cubies.forEach((cubie) => {\n            if (cubie.fixedPositionVector.x === 1 && cubie.fixedPositionVector.y === -1 && cubie.fixedPositionVector.z === 1) {\n                const pos = cubie.fixedPositionVector.clone();\n                pos.project(camera);\n                rotationPixelCutoff = pos.x * halfWidth + halfWidth;\n            }\n        });\n    };\n    updateRotationPixelCutoff();\n    controls.addEventListener(\"change\", updateRotationPixelCutoff); // Updating rotation pixel cutoff on zoom\n\n    const solveCube = () => {\n        // Functionality for solving the cube\n        console.log(\"Cube solving functionality has been disabled.\");\n        solving = false;\n    };\n\n    const clock = new THREE.Clock(); // Clock for tracking time\n\n    // Function for making updates per tick\n    const update = () => {\n        const delta = clock.getDelta();\n\n        if (!animating && moveBuffer.length > 0) {\n            const move = moveBuffer.shift();\n\n            if (move === MoveFlags.SOLUTION_END) {\n                solving = false;\n                animating = false;\n            } else if (move === MoveFlags.SOLUTION_START) {\n                solveCube();\n            } else {\n                cube.move(move);\n                animating = true;\n            }\n        }\n\n        // if any cubie is animating, perform the animation\n        cube.forEach((cubie) => {\n            if (cubie.animating) {\n                if (cubie.angle >= Math.PI * 0.5) {\n                    // if it's finished rotating 90 degrees\n                    cubie.angle = 0;\n                    cubie.animating = false;\n                    cubie.turn(cubie.animateAxis, cubie.animateDir);\n                    cubie.lockPosition();\n                    animating = false;\n                } else {\n                    // if it's still rotating\n                    cubie.rotate(\n                        cubie.animateAxis,\n                        cubie.animateDir * delta * ANIMATION_SPEED\n                    );\n                    cubie.angle += delta * ANIMATION_SPEED;\n                }\n            }\n        });\n    };\n\n    // Animation function to be called with requestAnimationFrame\n    const animate = () => {\n        requestAnimationFrame(animate);\n        update();\n        renderer.render(scene, camera);\n    };\n    animate(); // Start the animation loop\n\n    // Event handlers for keyboard and mouse events, resize, and touch\n\n    /**\n     * Handle key press event\n     */\n    const onKeyPress = (event) => {\n        // do nothing if solving\n        if (solving) return;\n\n        // append 'w' if holding w\n        const key = holdingW ? \"w\" + event.key : event.key;\n\n        if (KeysToMoves[key] !== undefined) {\n            // push normal move if key is in KeysToMoves map\n            moveBuffer.push(KeysToMoves[key]);\n        } else if (event.key === \"Enter\") {\n            // set solving to true and queue a solve request\n            solving = true;\n            moveBuffer.push(MoveFlags.SOLUTION_START);\n        } else if (event.key === \"w\" || event.key === \"W\") {\n            holdingW = true;\n        }\n    };\n    document.addEventListener(\"keypress\", onKeyPress, false);\n\n    /**\n     * Handle key up event\n     */\n    const onKeyUp = (event) => {\n        // unset holdingW if released w\n        if (event.key === \"w\" || event.key === \"W\") holdingW = false;\n    };\n    document.addEventListener(\"keyup\", onKeyUp, false);\n\n    /**\n     * Resize canvas on window resize\n     */\n    const onWindowResize = () => {\n        camera.aspect = window.innerWidth / getHeight();\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, getHeight());\n        updateRotationPixelCutoff();\n    };\n    window.addEventListener(\"resize\", onWindowResize, false);\n\n    /**\n     * Route touch events to mouse events\n     */\n    const onTouchStart = (event) => {\n        event.offsetX = event.touches[0].clientX;\n        event.offsetY = event.touches[0].clientY - getHeaderSize();\n        onDocumentMouseDown(event);\n    };\n    document.addEventListener(\"touchstart\", onTouchStart, false);\n\n    const onTouchEnd = (event) => {\n        onDocumentMouseUp(event);\n    };\n    document.addEventListener(\"touchend\", onTouchEnd, false);\n\n    const onTouchMove = (event) => {\n        event.offsetX = event.touches[0].clientX;\n        event.offsetY = event.touches[0].clientY - getHeaderSize();\n        onDocumentMouseMove(event);\n    };\n    document.addEventListener(\"touchmove\", onTouchMove, false);\n\n    /**\n     * Mouse events\n     */\n    // variables to store the chosen move based on the mouse events\n    let chosenAxis = null;\n    let chosenDir = 0;\n    let selectedObject = ClickFlags.NONE;\n    let dragging = false;\n\n    /**\n     * Handle clicks by finding the mesh that was clicked.\n     */\n    const onDocumentMouseDown = (event) => {\n        // only handle events targeting the canvas\n        if (event.target.tagName.toLowerCase() !== \"canvas\") return;\n\n        // set dragging to true\n        dragging = true;\n\n        // update mouse location\n        mouse.x = (event.offsetX / window.innerWidth) * 2 - 1;\n        mouse.y = -(event.offsetY / getHeight()) * 2 + 1;\n\n        // use raycaster to find what cube meshes intersect mouse position\n        raycaster.setFromCamera(mouse.clone(), camera);\n        const intersects = raycaster.intersectObjects(cube.meshes, true);\n\n        // if nothing was clicked, signal a cube rotation\n        if (intersects.length === 0) {\n            selectedObject = ClickFlags.ROTATION;\n            return;\n        }\n\n        // update selectedObject if the topmost mesh is in the cube's stickersMap\n        if (cube.stickersMap.has(intersects[0].object.uuid)) {\n            selectedObject = intersects[0];\n        } else {\n            // this case happens when the black cubie in between the stickers is clicked\n            // set selectedObject to special CUBIE flag\n            selectedObject = ClickFlags.CUBIE;\n        }\n    };\n    document.addEventListener(\"pointerdown\", onDocumentMouseDown, false);\n\n    /**\n     * Handle mouse release by unsetting chosen axis, direction, and selected object.\n     */\n    const onDocumentMouseUp = (event) => {\n        dragging = false;\n        selectedObject = ClickFlags.NONE;\n        chosenAxis = null;\n        chosenDir = 0;\n    };\n    document.addEventListener(\"pointerup\", onDocumentMouseUp, false);\n\n    /**\n     * Handle mouse move events by determining what\n     * move is being requested, and pushing it to the moveBuffer.\n     */\n    const onDocumentMouseMove = (event) => {\n        // do nothing if not dragging, or if solving\n        if (!dragging || chosenAxis !== null || solving) return;\n\n        // do nothing if clicked a cubie\n        if (selectedObject === ClickFlags.CUBIE) return;\n\n        // find the difference of the current mouse position from where the click began\n        delta.x = (event.offsetX / window.innerWidth) * 2 - 1 - mouse.x;\n        delta.y = -(event.offsetY / getHeight()) * 2 + 1 - mouse.y;\n\n        // do nothing if mouse hasn't moved far enough\n        if (delta.length() <= getTolerance()) return;\n\n        // determine if swipe is up/down or left/right\n        if (Math.abs(delta.x) > Math.abs(delta.y)) {\n            // if change was more in X direction than Y, then moving left/right\n            chosenAxis = Axes.POSITIVE.X;\n            chosenDir = delta.x > 0 ? 1 : -1;\n        } else {\n            // if change was more in Y direction than X, then moving up/down\n            chosenAxis = Axes.POSITIVE.Y;\n            chosenDir = delta.y > 0 ? 1 : -1;\n        }\n\n        // check if this is a cube rotation or a turn\n        if (selectedObject === ClickFlags.ROTATION) {\n            // do a cube rotation\n            if (chosenAxis === Axes.POSITIVE.X) {\n                if (chosenDir === -1) moveBuffer.push(\"y\");\n                else if (chosenDir === 1) moveBuffer.push(\"y'\");\n            } else if (chosenAxis === Axes.POSITIVE.Y) {\n                if (event.offsetX < rotationPixelCutoff) {\n                    // do an x rotation if to the left of the pixel cutoff\n                    if (chosenDir === -1) moveBuffer.push(\"x'\");\n                    else if (chosenDir === 1) moveBuffer.push(\"x\");\n                } else {\n                    // do a z rotation if to the right\n                    if (chosenDir === -1) moveBuffer.push(\"z\");\n                    else if (chosenDir === 1) moveBuffer.push(\"z'\");\n                }\n            }\n            return;\n        }\n\n        // user is performing a move\n\n        // get the mesh for the selected sticker\n        const selectedSticker = cube.stickersMap.get(selectedObject.object.uuid);\n        // check what direction the swipe was in\n        if (chosenAxis === Axes.POSITIVE.X) {\n            // swiping right/left\n            if (selectedSticker.fixedFacingVector.y === 1) {\n                // the selected sticker is facing up\n                switch (selectedSticker.fixedPositionVector.z) {\n                    // piece is in the back layer\n                    case -1:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"B'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"B\");\n                        break;\n                    // piece is in the S slice\n                    case 0:\n                        if (chosenDir === -1) moveBuffer.push(\"S'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"S\");\n                        break;\n                    // piece is in the front layer\n                    case 1:\n                        if (chosenDir === -1) moveBuffer.push(\"F'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"F\");\n                        break;\n                    default:\n                        break;\n                }\n            } else {\n                // the selected sticker is facing right or front\n                switch (selectedSticker.fixedPositionVector.y) {\n                    // piece is in bottom layer\n                    case -1:\n                        if (chosenDir === -1) moveBuffer.push(\"D'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"D\");\n                        break;\n                    // piece is in E slice\n                    case 0:\n                        if (chosenDir === -1) moveBuffer.push(\"E'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"E\");\n                        break;\n                    // piece is in up layer\n                    case 1:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"U'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"U\");\n                        break;\n                    default:\n                        break;\n                }\n            }\n        } else if (chosenAxis === Axes.POSITIVE.Y) {\n            // swiping up/down\n            if (selectedSticker.fixedFacingVector.x === 1) {\n                // selected sticker is facing right\n                switch (selectedSticker.fixedPositionVector.z) {\n                    // piece is in back layer\n                    case -1:\n                        if (chosenDir === -1) moveBuffer.push(\"B'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"B\");\n                        break;\n                    // piece is in S slice\n                    case 0:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"S'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"S\");\n                        break;\n                    // piece is in front layer\n                    case 1:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"F'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"F\");\n                        break;\n                    default:\n                        break;\n                }\n            } else {\n                // selected sticker is facing up or front\n                switch (selectedSticker.fixedPositionVector.x) {\n                    // piece is in left layer\n                    case -1:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"L'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"L\");\n                        break;\n                    // piece is in M slice\n                    case 0:\n                        if (-1 * chosenDir === -1) moveBuffer.push(\"M'\");\n                        else if (-1 * chosenDir === 1) moveBuffer.push(\"M\");\n                        break;\n                    // piece is in right layer\n                    case 1:\n                        if (chosenDir === -1) moveBuffer.push(\"R'\");\n                        else if (chosenDir === 1) moveBuffer.push(\"R\");\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        // set dragging to false to not trigger another move\n        dragging = false;\n    };\n    document.addEventListener(\"pointermove\", onDocumentMouseMove, false);\n};","import React, { createContext, useContext, useState, useMemo, useCallback } from 'react';\n\nconst ModalContext = createContext();\n\nexport const useModal = () => useContext(ModalContext);\n\nexport const ModalProvider = ({ children }) => {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [currentVideoID, setCurrentVideoID] = useState(null);\n\n  // OpenModal function updated to simply set the modal state and current video ID.\n  // This handles opening the modal both programmatically and via URL navigation.\n  const openModal = useCallback((videoID) => {\n    console.log(`Opening modal for videoID: ${videoID}`);\n    setIsModalOpen(true);\n    setCurrentVideoID(videoID);\n  }, []);\n\n  // CloseModal function simplified to remove the previously included navigateCallback parameter.\n  // The function now purely focuses on closing the modal and resetting relevant state.\n  // This change is based on the finding that navigateCallback was unnecessary and could potentially cause routing issues.\n  const closeModal = useCallback(() => {\n    console.log('Closing modal');\n    setIsModalOpen(false);\n    setCurrentVideoID(null);\n  }, []);\n\n  // The context value is memoized to ensure that consumers of the context do not re-render unnecessarily.\n  // This is particularly important for performance, as it prevents unnecessary re-renders of components that use this context.\n  const providerValue = useMemo(() => ({\n    isModalOpen,\n    currentVideoID,\n    openModal,\n    closeModal\n  }), [isModalOpen, currentVideoID, openModal, closeModal]);\n\n  return (\n    <ModalContext.Provider value={providerValue}>\n      {children}\n    </ModalContext.Provider>\n  );\n};","import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport axios from 'axios';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useModal } from './ModalContext';\n\nconst BASE_URL = process.env.NODE_ENV === 'production'\n  ? 'https://vujade-site-bd6c94750c62.herokuapp.com'\n  : 'http://127.0.0.1:5000';\n\n  function Modal() {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { isModalOpen, currentVideoID, closeModal } = useModal();\n    const [videoInfo, setVideoInfo] = useState(null);\n    const [isLoading, setIsLoading] = useState(false);\n    const modalRef = useRef(null);\n\n  // Function to transform video URLs for embedding\n  const getEmbeddedVideoUrl = useCallback((url) => {\n    const parts = url.split(\"vimeo.com/\")[1];\n    const vimeoId = parts.split('/')[0];\n    return `https://player.vimeo.com/video/${vimeoId}`;\n  }, []);\n\n   // Fetch and set video info based on URL change or currentVideoID update\n   useEffect(() => {\n    const videoIDFromURL = location.pathname.split('/')[1];\n    if (videoIDFromURL && (videoIDFromURL !== currentVideoID || !videoInfo)) {\n      setIsLoading(true); // Indicate loading\n      axios.get(`${BASE_URL}/api/video_info/${videoIDFromURL}`)\n        .then(response => {\n          setVideoInfo(response.data);\n          setIsLoading(false); // Reset loading state\n        })\n        .catch(error => {\n          console.error('Error fetching video info: ', error);\n          setIsLoading(false); // Ensure loading state is reset even on error\n        });\n    }\n  }, [location.pathname, currentVideoID, videoInfo]);\n\n  const handleCloseModal = useCallback(() => {\n    closeModal();\n    navigate('/'); // Use navigate to change URL back to root\n  }, [closeModal, navigate]);\n\n  // Memoize embedded video URL\n  const embeddedVideoUrl = useMemo(() => videoInfo ? getEmbeddedVideoUrl(videoInfo.URL) : null, [videoInfo, getEmbeddedVideoUrl]);\n\n  if (isLoading || !videoInfo) { // Show loading indicator or prevent rendering if videoInfo is not available yet\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    <div className={`modal-backdrop ${isModalOpen ? 'open' : ''}`} onClick={handleCloseModal} ref={modalRef}>\n      <div className=\"modal\" onClick={(e) => e.stopPropagation()}>\n        <div className=\"modal-content\">\n          <span className=\"close\" onClick={handleCloseModal}>&times;</span>\n          <>\n            <h2>{videoInfo ? videoInfo.videoName : 'Loading...'}</h2>\n            <div className=\"embed-container\">\n              {videoInfo && (\n                <iframe\n                  src={embeddedVideoUrl}\n                  allow=\"autoplay; fullscreen\"\n                  allowFullScreen\n                  title={videoInfo ? videoInfo.videoName : ''}\n                ></iframe>\n              )}\n            </div>\n            {videoInfo && <div dangerouslySetInnerHTML={{ __html: videoInfo.Description }}></div>}\n          </>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default Modal;","import React, { useState, useEffect, Suspense, useMemo, useRef } from 'react';\nimport axios from 'axios';\nimport './App.css';\nimport { CubeMasterInit } from './cube-master/js/cube/main.js';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport { ModalProvider } from './ModalContext';\nimport Modal from './Modal';\nimport _ from 'lodash';\n\nconst BASE_URL = process.env.NODE_ENV === 'production'\n  ? 'https://vujade-site-bd6c94750c62.herokuapp.com'\n  : 'http://127.0.0.1:5000';\n\nfunction CubeWithVideos() {\n  const [cubeVideos, setCubeVideos] = useState([]);\n  const cubeMasterInitialized = useRef(false);\n\n  useEffect(() => {\n    console.log('CubeWithVideos component mounted.');\n\n    return () => {\n      console.log('CubeWithVideos component unmounted.');\n      // Add cleanup logic here if necessary, such as CubeMasterCleanup();\n    };\n  }, []);\n\n  useEffect(() => {\n    const fetchCubeVideos = async () => {\n      try {\n        const response = await axios.get(`${BASE_URL}/api/scenes`);\n        const shuffledScenes = _.shuffle(response.data.map(scene => scene.sceneURL));\n        setCubeVideos(shuffledScenes);\n      } catch (error) {\n        console.error('Error fetching cube videos:', error);\n      }\n    };\n    fetchCubeVideos();\n  }, []);\n\n  useEffect(() => {\n    if (cubeVideos.length > 0 && !cubeMasterInitialized.current) {\n      console.log('Initializing CubeMaster with new video textures');\n      CubeMasterInit(cubeVideos);\n      cubeMasterInitialized.current = true;\n    }\n  }, [cubeVideos]);\n\n  return <div id=\"cube-container\"></div>;\n}\n\nfunction VideoMenu() {\n  const [videoNames, setVideoNames] = useState([]);\n\n  useEffect(() => {\n    const fetchVideoNames = async () => {\n      try {\n        const response = await axios.get(`${BASE_URL}/api/videos`);\n        setVideoNames(response.data.map(video => ({\n          id: video.videoID,\n          name: video.videoName\n        })));\n      } catch (error) {\n        console.error('Error fetching video names:', error);\n      }\n    };\n    fetchVideoNames();\n  }, []);\n\n  return (\n    <div className=\"video-menu\">\n      {videoNames.map(video => (\n        <button key={video.id} onClick={() => console.log('Clicked:', video.name)}>\n          {video.name}\n        </button>\n      ))}\n    </div>\n  );\n}\n\nfunction Home() {\nreturn (\n  <>\n    <CubeWithVideos />\n  </>\n);\n}\n\nfunction AppWrapper() {\n  const [scenes, setScenes] = useState([]);\n  const [uniqueVideoIDs, setUniqueVideoIDs] = useState([]);\n\n  useEffect(() => {\n    const fetchContent = async () => {\n      const scenesResponse = await axios.get(`${BASE_URL}/api/scenes`);\n      setScenes(scenesResponse.data);\n      const videosResponse = await axios.get(`${BASE_URL}/api/videos`);\n      setUniqueVideoIDs(_.uniqBy(videosResponse.data, 'videoID'));\n    };\n    fetchContent();\n  }, []);\n\n  const memoizedScenes = useMemo(() => scenes, [scenes]);\n  const memoizedUniqueVideoIDs = useMemo(() => uniqueVideoIDs, [uniqueVideoIDs]);\n\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <ModalProvider>\n          <VideoMenu />\n          <Routes>\n            <Route path=\"/\" element={<Home scenes={memoizedScenes} uniqueVideoIDs={memoizedUniqueVideoIDs} />} />\n            <Route path=\"/:videoID\" element={\n              <>\n                <Home scenes={memoizedScenes} uniqueVideoIDs={memoizedUniqueVideoIDs} />\n                <Modal />\n              </>\n            } />\n          </Routes>\n        </ModalProvider>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default AppWrapper;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport { ModalProvider } from './ModalContext';\nimport reportWebVitals from './reportWebVitals';\n\n// Use the createRoot API\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <ModalProvider>\n      <App />\n    </ModalProvider>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}